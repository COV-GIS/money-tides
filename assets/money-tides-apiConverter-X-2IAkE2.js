import{a as l,m as V}from"./money-tides-Point2D-B_0jPIXb.js";import"./money-tides-Envelope2D-CT8brdER.js";import{r as M,c as w,e as p,O as P,Y as Z}from"./money-tides-ProjectionTransformation-CbLB2tLt.js";import{bT as v,ar as R,_ as h,aS as d,at as E}from"./money-tides-app-config-ClMBcfMD.js";import{fromGeometryToGXGeometry as g,toGeometry as y}from"./money-tides-jsonConverter-DNW8Q1GR.js";import"./money-tides-Transformation2D-FgOqqMH4.js";import"./money-tides-SimpleGeometryCursor-B92kdZ15.js";import"./money-tides-jsxFactory-B_9qB7yw.js";import"./money-tides-config-Dy31BTur.js";import"./index-D3fz2Vbf.js";import"./money-tides-index-Bz5uSspo.js";import"./money-tides-runtime-BTGwkf2p.js";import"./money-tides-OperatorDefinitions-DP7_WWTp.js";import"./money-tides-ReactiveMap-CNCn77NR.js";import"./money-tides-messageBundle-GAipSWXq.js";import"./money-tides-index-BSQMl5Dg.js";const a="_gxVersion",x=2,C=1;function tt(t){return Array.isArray(t)?t[0].spatialReference:t.spatialReference}function et(t){switch(t.type){case"point":return G(t);case"multipoint":return Y(t);case"polyline":return k(t);case"polygon":return X(t);case"extent":return z(t);default:throw new Error(`Unsupported geometry type: ${t.type}`)}}function z(t){if(!t.getCacheValue(a)){const e=new M;e.setCoords(t.xmin,t.ymin,t.xmax,t.ymax),t.hasM&&e.setInterval(x,0,t.mmin,t.mmax),t.hasZ&&e.setInterval(C,0,t.zmin,t.zmax),t.setCacheValue(a,e)}return t.getCacheValue(a)}function Y(t){if(!t.getCacheValue(a)){const e=new w,n=new p,r=t.points,s=t.hasM,o=t.hasZ,i=o?3:2;for(let u=0,m=r.length;u<m;u++){const c=r[u];n.setXYCoords(c[0],c[1]),o&&n.setZ(c[2]??0),s&&n.setM(c[i]??NaN),e.add(n)}t.setCacheValue(a,e)}return t.getCacheValue(a)}function G(t){if(!t.getCacheValue(a)){const e=new p;e.setXYCoords(t.x,t.y),t.hasM&&e.setM(t.m),t.hasZ&&e.setZ(t.z),t.setCacheValue(a,e)}return t.getCacheValue(a)}function X(t){if(!t.getCacheValue(a)){const{curveRings:e,hasM:n,hasZ:r,rings:s}=t,o=g({curveRings:e,hasM:n,hasZ:r,rings:s});t.setCacheValue(a,o)}return t.getCacheValue(a)}function k(t){if(!t.getCacheValue(a)){const{curvePaths:e,hasM:n,hasZ:r,paths:s}=t,o=g({curvePaths:e,hasM:n,hasZ:r,paths:s});t.setCacheValue(a,o)}return t.getCacheValue(a)}function nt(t){if(t.wkid)return P(t.wkid);const e=t.wkt2||t.wkt;return e?Z(e):null}function at(t,e){if(t)switch(t.getGeometryType()){case l.enumPoint:return N(t,e);case l.enumEnvelope:return S(t,e);case l.enumMultiPoint:return I(t,e);case l.enumPolyline:return $(t,e);case l.enumPolygon:return O(t,e)}return null}function S(t,e){if(t.isEmpty())return null;const n=new v({xmin:t.getXMin(),ymin:t.getYMin(),xmax:t.getXMax(),ymax:t.getYMax(),spatialReference:e}),r=t.getDescription();if(r.hasM()){const s=t.queryInterval(x,0);n.mmin=s.vmin,n.mmax=s.vmax}if(r.hasZ()){const s=t.queryInterval(C,0);n.zmin=s.vmin,n.zmax=s.vmax}return n.setCacheValue(a,t),n}function I(t,e){if(t.isEmpty())return null;const n=t.getDescription(),r=n.hasM(),s=n.hasZ(),o=[],i=new p;for(let m=0,c=t.getPointCount();m<c;m++){t.getPointByVal(m,i);const f=[i.getX(),i.getY()];s&&f.push(i.getZ()),r&&f.push(i.getM()),o.push(f)}const u=new R({hasM:r,hasZ:s,points:o,spatialReference:e});return u.setCacheValue(a,t),u}function N(t,e){if(t instanceof V)return new h({x:t.x,y:t.y,spatialReference:e});if(t.isEmpty())return null;const n=new h({x:t.getX(),y:t.getY(),spatialReference:e}),r=t.getDescription();return r.hasM()&&(n.m=t.getM()),r.hasZ()&&(n.z=t.getZ()),n.setCacheValue(a,t),n}function O(t,e){if(t.isEmpty())return null;const n=d.fromJSON({spatialReference:e,...y(t,null)});return n.setCacheValue(a,t),n}function $(t,e){if(t.isEmpty())return null;const n=E.fromJSON({spatialReference:e,...y(t,null)});return n.setCacheValue(a,t),n}export{z as fromExtent,et as fromGeometry,Y as fromMultipoint,G as fromPoint,X as fromPolygon,k as fromPolyline,nt as fromSpatialReference,tt as getSpatialReference,S as toExtent,at as toGeometry,I as toMultipoint,N as toPoint,O as toPolygon,$ as toPolyline};
