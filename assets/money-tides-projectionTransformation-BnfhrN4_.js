import{t as p,a as f,z as c,b as m,R as d,d as g,J as l,W as u}from"./money-tides-ProjectionTransformation-7-kpGQW7.js";import"./money-tides-Point2D-DZxdVGVN.js";import{Envelope2D as x}from"./money-tides-Envelope2D-BplJ_SDb.js";import"./money-tides-Transformation2D-Dbl8POun.js";import"./money-tides-SimpleGeometryCursor-B92kdZ15.js";import"./money-tides-jsxFactory-DhEmlXtp.js";import"./index-DssDhHvH.js";import"./money-tides-runtime-BAFbAsol.js";import"./money-tides-OperatorDefinitions-DP7_WWTp.js";function P(t,n,e){let i,s;if(e?.geographicTransformation){if(e.geographicTransformation.steps?.length){const r=new p;r.setInputSpatialReference(t),r.setOutputSpatialReference(n);for(const a of e.geographicTransformation.steps){let o;o=a.wkid?f(a.wkid,a.isInverse):c(a.wkt,a.isInverse),r.add(o)}i=r.create()}else i=l();if(e.extendedParams){s=u();const{densificationStep:r}=e.extendedParams;r!=null&&(s.densificationStep=r)}}else if(e?.areaOfInterestExtent)return m(t,n,I(e.areaOfInterestExtent));return i?d(t,n,i,s):g(t,n)}function I(t){return x.construct(t.xmin,t.ymin,t.xmax,t.ymax)}export{P as createProjectionTransformation};
