import{h as A}from"./money-tides-config-BVnrMf5g.js";import{em as b,bD as d,en as P,eo as B,ep as v,aN as C,eq as E,er as j,es as z,et as U,eu as F,ev as G}from"./money-tides-app-config-DspwKZVt.js";import{c as H}from"./money-tides-GraphicManipulator-B8d9b_BV.js";function R(n,e,s,t){if(n.type==="point")return n.x+=e,n.y+=s,n.hasZ&&t!=null,n;if(n.type==="multipoint"){const r=n.points;for(let i=0;i<r.length;i++)r[i]=w(r[i],e,s,t);return n}if(n.type==="extent")return n.xmin+=e,n.xmax+=e,n.ymin+=s,n.ymax+=s,n;const o=n.type==="polyline"?n.curvePaths??n.paths:n.curveRings??n.rings,c=E(n);for(let r=0;r<o.length;r++){const i=o[r];for(let y=0;y<i.length;y++)i[y]=J(i[y],e,s,t)}return"paths"in n?c?n.curvePaths=o:n.paths=o:c?n.curveRings=o:n.rings=o,n}function S(n,e,s,t,o){const c=n.clone();if(o){const{resolution:r}=t;R(c,e*r,-s*r)}else{const{dxMap:r,dyMap:i}=I(e,s,t);R(c,r,i)}return c}function I(n,e,s){const t=s.state.inverseTransform;return{dxMap:t[0]*n+t[2]*e,dyMap:t[1]*n+t[3]*e}}function w(n,e,s,t){return D(n,n[0]+e,n[1]+s,n[2]!=null&&t!=null?n[2]+t:void 0)}function J(n,e,s,t){const o=w(v(n),e,s,t);if(j(n))return o;if(z(n)){const[,i,y]=n.b;return{b:[o,[i[0]+e,i[1]+s],[y[0]+e,y[1]+s]]}}if(U(n)){const[,i]=n.c;return{c:[o,[i[0]+e,i[1]+s]]}}const[,c,...r]=n.a;return{a:[o,[c[0]+e,c[1]+s],...r]}}function V(n,e,s,t){if(n.type==="point"){const{x:u,y:f}=n,m=t?t[0]:u,l=t?t[1]:f,x=n.clone(),p=(u-m)*e+m,a=(f-l)*s+l;return x.x=p,x.y=a,x}if(n.type==="extent"){const{xmin:u,xmax:f,ymin:m,ymax:l}=n,x=t?t[0]:(u+f)/2,p=t?t[1]:(l+m)/2,a=n.clone();if(a.xmin=(u-x)*e+x,a.ymax=(l-p)*s+p,a.xmax=(f-x)*e+x,a.ymin=(m-p)*s+p,a.xmin>a.xmax){const h=a.xmin,M=a.xmax;a.xmin=M,a.xmax=h}if(a.ymin>a.ymax){const h=a.ymin,M=a.ymax;a.ymin=M,a.ymax=h}return a}let o=null;if(!t){o=b(n);const u=d(),f=P(u,o);if(!f)return n.clone();const[m,l,x,p]=f;t=[(m+x)/2,(l+p)/2]}const[c,r]=t;if(n.type==="multipoint"){const u=n.clone(),f=u.points;for(let m=0;m<f.length;m++){const l=f[m],[x,p]=l,a=(x-c)*e+c,h=(p-r)*s+r;f[m]=D(l,a,h,void 0)}return u.points=f,u}const i=n.clone();o??=b(n);const y=i.type==="polygon",g=y?i.curveRings??i.rings:i.curvePaths??i.paths;if(!t){const u=d(),f=P(u,g,!1,!1);if(!f)return i;t=B(f)}for(const u of g){let f=null;const m=y&&u.length>0&&A(v(u[0]),v(u.at(-1)));for(let l=0;l<u.length;l++){const x=u[l];u[l]=K(x,e,s,c,r,f),f=x}m&&(u[0]=[...v(u.at(-1))])}return i}function q(n,e,s,t,o){const[c,r,...i]=n;return[(c-t)*e+t,(r-o)*s+o,...i]}function K(n,e,s,t,o,c){if(j(n))return q(n,e,s,t,o);if(z(n)){const[N,T,Z]=n.b.map(k=>q(k,e,s,t,o));return{b:[N,T,Z]}}if(!c)return n;const r=v(c),i=U(n)?F(r,n):n,[y,g,u,f,m,l,x]=i.a,p=m??0,a=l??Math.hypot(y[0]-g[0],y[1]-g[1]),h=x??1,M=H(t,o,1,0,0,1,e,s);return G(r,{a:[[...y],[...g],u,f,p,a,h]},M)}function W(n,e,s,t,o,c){const r=Math.sqrt((s-n)*(s-n)+(t-e)*(t-e));return Math.sqrt((o-n)*(o-n)+(c-e)*(c-e))/r}function X(n,e,s,t=!1){const o=Math.atan2(e.y-s.y,e.x-s.x)-Math.atan2(n.y-s.y,n.x-s.x),c=Math.atan2(Math.sin(o),Math.cos(o));return t?c:C(c)}function D(n,e,s,t){const o=[e,s];return n.length>2&&o.push(t??n[2]),n.length>3&&o.push(n[3]),o}export{V as M,W as U,X as b,I as h,S as x};
