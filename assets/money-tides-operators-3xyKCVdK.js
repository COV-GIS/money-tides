import{NonSimpleResult as v}from"./money-tides-OperatorDefinitions-DP7_WWTp.js";import{execute as S}from"./money-tides-affineTransformOperator-DNqrOH1p.js";import{fV as l,N as j,p0 as O}from"./index-VH6VYgR7.js";import{p1 as mt}from"./index-VH6VYgR7.js";import{m as C}from"./money-tides-geodeticAreaOperator-DGATFbjZ.js";import{f as lt}from"./money-tides-geodeticAreaOperator-DGATFbjZ.js";import{l as G}from"./money-tides-geodeticDensifyOperator-DQZB1O2H.js";import{g as $t}from"./money-tides-geodeticDensifyOperator-DQZB1O2H.js";import{m as w}from"./money-tides-geodeticLengthOperator-BgdJqSlz.js";import{f as _t}from"./money-tides-geodeticLengthOperator-BgdJqSlz.js";import{isSimple as M}from"./money-tides-simplifyOGCOperator-kMi3bvWw.js";import P from"./money-tides-Transformation-Bhcj-o1o.js";import{i as dt}from"./money-tides-areaOperator-BZKrsor1.js";import{x as z,l as R,f as T}from"./money-tides-operatorBuffer-NtLJgx2W.js";import{getSpatialReference as a,fromGeometry as r,fromSpatialReference as o,toPolygon as d,toGeometry as u}from"./money-tides-apiConverter-ByvLnoBa.js";import{p as vt}from"./money-tides-centroidOperator-CaQ7jdZK.js";import{i as jt}from"./money-tides-clipOperator-BM6xqcCY.js";import{u as Ct}from"./money-tides-containsOperator-EAA7m9GN.js";import{q as D,D as h,_ as N,w as A}from"./money-tides-operatorConvexHull-D4gjjA8S.js";import{t as q}from"./money-tides-OperatorCrosses-DOYrYgdp.js";import{i as wt}from"./money-tides-cutOperator-DZWxsAnw.js";import{l as Pt}from"./money-tides-densifyOperator-yYG6xbm6.js";import{m as Rt}from"./money-tides-differenceOperator-h6wC1p8K.js";import{ac as F}from"./money-tides-ProjectionTransformation-kFJHFk2G.js";import{i as Dt}from"./money-tides-distanceOperator-QWYamHRD.js";import{l as Nt}from"./money-tides-equalsOperator-nXvCyVd0.js";import{c as qt}from"./money-tides-generalizeOperator-C1gUVpKG.js";import{l as It}from"./money-tides-intersectionOperator-ByZT4H-y.js";import{p as Bt}from"./money-tides-intersectsOperator-CN-LraAW.js";import{c as Lt}from"./money-tides-labelPointOperator-De303Awl.js";import{n as kt}from"./money-tides-lengthOperator-bAPDBqt4.js";import{t as I}from"./money-tides-OperatorOverlaps-Z27oGL5D.js";import{g as Jt}from"./money-tides-proximityOperator-B6vOdxZ9.js";import{y as Qt}from"./money-tides-relateOperator-D4wKkczK.js";import{f as Wt}from"./money-tides-simplifyOperator-BeWUE6j3.js";import{i as Yt}from"./money-tides-symmetricDifferenceOperator-DXbITc0a.js";import{t as V}from"./money-tides-OperatorTouches-B5CvK53v.js";import{s as B,o as H,r as L}from"./money-tides-operatorUnion-rN3BuEXt.js";import{t as Z}from"./money-tides-OperatorWithin-rK2wLrF1.js";import{executeOffset as tr}from"./money-tides-offset-C3rZ8O8q.js";import"./money-tides-Point2D-ySXOP2mt.js";import"./money-tides-Envelope2D-B2N9ln76.js";import"./money-tides-Transformation2D-SUWYza7f.js";import"./money-tides-jsonConverter-D7l0WfZV.js";import"./money-tides-operatorGeodeticDensify-6PDJNqS1.js";import"./money-tides-OperatorSimplifyOGC-DkfZdP19.js";import"./money-tides-Bufferer-Dw9Qi4T1-BiGtvcus.js";import"./money-tides-GeometryCleaner-BEJM7I4l-CSB3y9V7.js";import"./money-tides-OperatorGeneralize-DELY32Kc.js";import"./money-tides-Centroid-DZi-eb9F-DzYaGPb9.js";import"./money-tides-Distance2DCalculator-CXhBP-8I-BZGlc8UQ.js";import"./money-tides-operatorGeneralize-DXF8M-O_.js";import"./money-tides-operatorIntersection-DOqkCuZi.js";import"./money-tides-OperatorIntersects-Da4cqCLE.js";import"./money-tides-OperatorProximity-Dr-J6aN8.js";import"./money-tides-operatorSimplify-CzKGVdeT.js";import"./money-tides-unitConversion-DV4jtDnT.js";import"./money-tides-operatorOffset-BjA3gVXz.js";function k(e,t,n={}){const{unit:s}=n,c=a(e);return s&&(t=l(t,s,c)),d(T(r(e),o(c),t),c)}function E(e,t,n={}){let{maxDeviation:s=NaN,maxVerticesInFullCircle:c=96,union:i=!1,unit:m}=n;const p=a(e);m&&(t=t.map(f=>l(f,m,p)),s&&(s=l(s,m,p)));const b=e.map(r);return R(b,o(p),t,s,c,i).map(f=>d(f,p)).filter(j)}const J=z(),Xe=Object.freeze(Object.defineProperty({__proto__:null,execute:k,executeMany:E,supportsCurves:J},Symbol.toStringTag,{value:"Module"}));function K(e){const t=a(e);return u(A(r(e)),t)}function Q(e,t={}){const{merge:n=!1}=t,s=e.map(r),c=a(e);return N(s,n).map(i=>u(i,c))}function U(e){return h(r(e))}const W=D(),Ye=Object.freeze(Object.defineProperty({__proto__:null,execute:K,executeMany:Q,isConvex:U,supportsCurves:W},Symbol.toStringTag,{value:"Module"})),x=new q;function X(e){const t=a(e);return x.accelerateGeometry(r(e),o(t),1)}function Y(e,t){return x.execute(r(e),r(t),o(e.spatialReference),null)}const ee=x.supportsCurves(),et=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:X,execute:Y,supportsCurves:ee},Symbol.toStringTag,{value:"Module"})),$=new F;function te(e){const t=a(e);return $.accelerateGeometry(r(e),o(t),1)}function re(e,t){return $.execute(r(e),r(t),o(e.spatialReference))}const oe=$.supportsCurves(),tt=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:te,execute:re,supportsCurves:oe},Symbol.toStringTag,{value:"Module"})),y=new I;function ne(e){const t=a(e);return y.accelerateGeometry(r(e),o(t),1)}function se(e,t){return y.execute(r(e),r(t),o(e.spatialReference),null)}const ae=y.supportsCurves(),rt=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:ne,execute:se,supportsCurves:ae},Symbol.toStringTag,{value:"Module"})),_=new V;function ce(e){const t=a(e);return _.accelerateGeometry(r(e),o(t),1)}function pe(e,t){return _.execute(r(e),r(t),o(e.spatialReference),null)}const ue=_.supportsCurves(),ot=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:ce,execute:pe,supportsCurves:ue},Symbol.toStringTag,{value:"Module"}));function ie(e,t){const n=a(e);return u(L(r(e),r(t),o(n)),n)}function me(e){const t=e.map(r),n=a(e);return u(H(t,o(n)),n)}const fe=B(),nt=Object.freeze(Object.defineProperty({__proto__:null,execute:ie,executeMany:me,supportsCurves:fe},Symbol.toStringTag,{value:"Module"})),g=new Z;function le(e){const t=a(e);return g.accelerateGeometry(r(e),o(t),1)}function xe(e,t){return g.execute(r(e),r(t),o(e.spatialReference),null)}const $e=g.supportsCurves(),st=Object.freeze(Object.defineProperty({__proto__:null,accelerateGeometry:le,execute:xe,supportsCurves:$e},Symbol.toStringTag,{value:"Module"}));function at(e,t,n,s){const c=new P().rotate(t,n,s);return S(e,c)}const ye=new Set([5,6,7,10,11,12]);function ct(e){const t=new v;return!M(e,t)&&ye.has(t.m_reason)}async function pt(){await Promise.all([C(),O(),G(),w()])}export{dt as area,Xe as buffer,vt as centroid,jt as clip,Ct as contains,Ye as convexHull,et as crosses,wt as cut,Pt as densify,Rt as difference,tt as disjoint,Dt as distance,Nt as equals,tr as executeOffset,qt as generalize,mt as geodesicBuffer,lt as geodeticArea,$t as geodeticDensify,_t as geodeticLength,It as intersection,Bt as intersects,ct as isSelfIntersecting,Lt as labelPoint,kt as length,pt as loadAll,rt as overlaps,Jt as proximity,Qt as relate,at as rotate,Wt as simplify,Yt as symmetricDifference,ot as touches,nt as union,st as within};
