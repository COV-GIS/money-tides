import{N as z,b as Q,h as Y}from"./money-tides-config-BVnrMf5g.js";import{aH as U,b3 as J,hn as K,f7 as V,eE as X,eI as ee,f5 as te,ho as se,h3 as re,az as ae,_ as M,hp as j,hq as ne,hr as ie,D as d,dB as oe,a9 as le,bL as ce,ad as he,ab as pe,gi as O,hs as ue,c7 as fe,cT as B,fY as de,ht as E,aI as me,aG as ye,dT as xe}from"./money-tides-app-config-bLoUqPNA.js";import{_ as v,m as S,b as ge}from"./money-tides-jsxFactory-B9QQWpgY.js";import{j as Re}from"./money-tides-geodesicUtils-mYxIuBpN.js";import{c as Me}from"./money-tides-distanceOperator-IS1TaCbN.js";import{c as we,u as Te}from"./money-tides-simplifyOperator-pMhWqcmZ.js";import{R as be,L as ve}from"./money-tides-quat-NbhT75YK.js";import{e as A}from"./money-tides-quatf64-aQ5IuZRd.js";var Z;let R=Z=class extends U{constructor(r){super(r),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}initialize(){const r=this.center,e=this.numberOfPoints;if(this.hasZ=r?.hasZ??!1,this.rings.length!==0||!r)return;const t=J(this.radius,this.radiusUnit,"meters"),a=r.spatialReference;let i,s="geographic";if(a.isWebMercator?s="webMercator":((a.wkid&&K[a.wkid])!=null||(a.wkt2||a.wkt)&&V(a.wkt2||a.wkt))&&(s="projected"),this.geodesic){let n;switch(s){case"webMercator":n=X(r);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":n=r}i=this._createGeodesicCircle(n,t,e),s==="webMercator"&&(i=ee(i))}else{let n;s==="webMercator"||s==="projected"?n=t/te(r.spatialReference):s==="geographic"&&(n=se(t,"meters",re(r.spatialReference).radius)),i=this._createPlanarCircle(r,n,e)}this.spatialReference=i.spatialReference,this.addRing(i.rings[0])}clone(){const{center:r,numberOfPoints:e,radius:t,radiusUnit:a,geodesic:i}=this;return new Z({center:r?.clone(),numberOfPoints:e,radius:t,radiusUnit:a,geodesic:i})}_createGeodesicCircle(r,e,t){const a=[],i=[r.x,r.y];for(let s=0;s<360;s+=360/t){const n=this.hasZ?[0,0,r.z??0]:[0,0];Re(n,i,s,e,ae.WGS84),a.push(n)}return a.push(a[0]),new U({rings:[a]})}_createPlanarCircle(r,e,t){const a=[],i=2*Math.PI/t;for(let s=0;s<t;++s){const n=i*s,c=[r.x+Math.cos(-n)*e,r.y+Math.sin(-n)*e];this.hasZ&&c.push(r.z??0),a.push(c)}return a.push(a[0]),new U({spatialReference:r.spatialReference,rings:[a]})}};v([S({type:M})],R.prototype,"center",void 0),v([S()],R.prototype,"geodesic",void 0),v([S()],R.prototype,"numberOfPoints",void 0),v([S()],R.prototype,"radius",void 0),v([S()],R.prototype,"radiusUnit",void 0),R=Z=v([ge("esri.geometry.Circle")],R);const We=R;function I(r,e,t=null){return t!=null?[r,e,t]:[r,e]}function o(r,e,t=null){return t!=null?{x:r,y:e,z:t}:{x:r,y:e}}class G{constructor(e){this.spatialReference=e}mapToLocalMultiple(e){return e.map(t=>this.mapToLocal(t)).filter(z)}get doUnnormalization(){return!1}}let $e=class extends G{constructor(e,t,a=null){super(t),this._defaultZ=a,this.transform=j(),this.transformInv=j(),this.transform=ne(e),ie(this.transformInv,this.transform)}makeMapPoint(e,t){return I(e,t,this._defaultZ)}mapToLocal(e){return o(this.transform[0]*e[0]+this.transform[2]*e[1]+this.transform[4],this.transform[1]*e[0]+this.transform[3]*e[1]+this.transform[5])}localToMap(e){return I(this.transformInv[0]*e.x+this.transformInv[2]*e.y+this.transformInv[4],this.transformInv[1]*e.x+this.transformInv[3]*e.y+this.transformInv[5],this._defaultZ)}},Se=class extends G{constructor(e,t){super(e.spatialReference),this.view=e,this.defaultZ=null,this.pWS=d(),this.tangentFrameUpWS=d(),this.tangentFrameRightWS=d(),this.tangentFrameForwardWS=d(),this.localFrameRightWS=d(),this.localFrameUpWS=d(),this.worldToLocalTransform=A(),this.localToWorldTransform=A(),this.scale=1,this.scale=e.resolution,this.referenceMapPoint=t,this.defaultZ=t.hasZ?t.z:null;const a=e.state.camera.viewRight;this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint,this.pWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,0,this.tangentFrameRightWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,1,this.tangentFrameUpWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,2,this.tangentFrameForwardWS);const i=d();oe(i,this.tangentFrameForwardWS,le(a,this.tangentFrameForwardWS)),ce(this.localFrameRightWS,a,i),he(this.localFrameRightWS,this.localFrameRightWS),pe(this.localFrameUpWS,this.tangentFrameForwardWS,this.localFrameRightWS),be(this.worldToLocalTransform,this.localFrameRightWS,this.tangentFrameRightWS),ve(this.localToWorldTransform,this.worldToLocalTransform)}get doUnnormalization(){return this.view.viewingMode==="global"}makeMapPoint(e,t){return I(e,t,this.defaultZ)}mapToLocal(e){const t=d();this.view.renderCoordsHelper.toRenderCoords(new M({x:e[0],y:e[1],spatialReference:this.spatialReference}),t),O(t,t,this.worldToLocalTransform);const a=this.view.renderCoordsHelper.fromRenderCoords(t,new M({spatialReference:this.view.spatialReference}));return a!=null?o(a.x/this.scale,a.y/this.scale):null}localToMap(e){const t=d();this.view.renderCoordsHelper.toRenderCoords(new M({x:e.x*this.scale,y:e.y*this.scale,spatialReference:this.spatialReference}),t),O(t,t,this.localToWorldTransform);const a=this.view.renderCoordsHelper.fromRenderCoords(t,new M({spatialReference:this.view.spatialReference}));return a!=null?I(a.x,a.y,this.defaultZ):null}};function He(r,e){if(r.type==="2d")return new $e(r.state.transform,r.spatialReference,e.length>2?e[2]:null);if(r.type==="3d"){const t=e.length>2?new M({x:e[0],y:e[1],z:e[2],spatialReference:r.spatialReference}):new M({x:e[0],y:e[1],spatialReference:r.spatialReference});return new Se(r,t)}return null}function w(r,e){const t=new M({x:r[0],y:r[1],spatialReference:e});return r.length>2&&(t.z=r[2]),t}function je(r,e){return new ye({points:r,spatialReference:e})}function Oe(r,e,t){const a=new me({paths:r,spatialReference:e});return t&&E(a),a}function L(r,e,t,a=!0){const i=Q(r);i.forEach(n=>{const c=n[0],l=n[n.length-1];Y(c,l)&&n.length!==1||n.push(n[0])});let s=new U({rings:i,spatialReference:e});return s.rings.forEach(n=>{de(n)||n.reverse()}),t&&E(s),a&&!we(s)&&B(e)&&(s=Te(s)||s),s}function Ae(r,e,t){const a=e.mapToLocalMultiple(r),i=[],s={x:a[0].x,y:a[0].y},n={x:a[1].x,y:a[1].y},c=Math.round(n.x-s.x),l=Math.round(n.y-s.y),u=Math.max(Math.abs(c),Math.abs(l));if(t){const h={x:s.x+u,y:s.y+u},m={x:s.x-u,y:s.y-u};i.push(o(h.x,m.y),o(m.x,m.y),o(m.x,h.y),o(h.x,h.y))}else{const h={x:c>0?s.x+u:s.x-u,y:l>0?s.y+u:s.y-u};i.push(o(s.x,s.y),o(h.x,s.y),o(h.x,h.y),o(s.x,h.y))}return q(L([i.map(h=>e.localToMap(h)).filter(z)],e.spatialReference,e.doUnnormalization,!0),i,e)}function Be(r,e,t){let a=e.mapToLocalMultiple(r);if(a.length===1){const l=a[0];a=[o(l.x-48,l.y+48),o(l.x+48,l.y-48),o(l.x+48,l.y-48),o(l.x-48,l.y+48)]}const i=[],s={x:a[0].x,y:a[0].y},n={x:a[1].x,y:a[1].y};if(t){const c=Math.round(n.x-s.x),l=Math.round(n.y-s.y);i.push(o(s.x-c,s.y-l),o(n.x,s.y-l),o(n.x,n.y),o(s.x-c,n.y))}else i.push(o(s.x,s.y),o(n.x,s.y),o(n.x,n.y),o(s.x,n.y));return q(L([i.map(c=>e.localToMap(c)).filter(z)],e.spatialReference,e.doUnnormalization,!0),i,e)}function q(r,e,t){const a=P(e[3],e[2],t),i=P(e[1],e[2],t),s=P(e[0],e[1],t),n=P(e[0],e[3],t);return{geometry:r,midpoints:a!=null&&i!=null&&s!=null&&n!=null?{top:a,right:i,bottom:s,left:n}:null}}function P(r,e,t){W[0]=r.x,W[1]=r.y,W[2]=0,$[0]=e.x,$[1]=e.y,$[2]=0,xe(W,W,$,.5),C.x=W[0],C.y=$[1],C.z=$[2];const a=t.localToMap(C);return a!=null?w(a,t.spatialReference):null}const C=o(0,0,0),W=d(),$=d();function Ee(r,e,t,a){const i=e.mapToLocalMultiple(r);let s=null,n=null;if(t)s=i[0],n=i[1];else{const p=i[0],f=i[1],T=Math.round(f.x-p.x),b=Math.round(f.y-p.y),y=Math.max(Math.abs(T),Math.abs(b));s=o(T>0?p.x+y/2:p.x-y/2,b>0?p.y+y/2:p.y-y/2),n=o(Math.abs(T)>Math.abs(b)?s.x-y/2:s.x,Math.abs(T)>Math.abs(b)?s.y:s.y-y/2)}const c=e.localToMap(s),l=e.localToMap(n);if(c==null||l==null)return null;e.doUnnormalization&&ue([[c,l]],e.spatialReference);const u=w(c,e.spatialReference),h=w(l,e.spatialReference),m=fe(e.spatialReference);let x=0;if(B(e.spatialReference))x=m*Me(u,h);else{const p=s.x-n.x,f=s.y-n.y;x=m*Math.sqrt(p*p+f*f)*1}const F=new We({center:u,radius:x,radiusUnit:"meters",spatialReference:e.spatialReference});return{geometry:L(F.rings,F.spatialReference,!1),center:u,edge:h}}function Ge(r,e,t){const a=e.mapToLocalMultiple(r),i=a[0],s=a[1],n=Math.round(s.x-i.x),c=Math.round(s.y-i.y),l=o(t?i.x:i.x+n/2,t?i.y:i.y+c/2),u=t?n:n/2,h=t?c:c/2,m=60,x=[],F=2*Math.PI/m;function p(g){const N=Math.cos(g),D=Math.sin(g);return o(u*N+l.x,h*D+l.y)}for(let g=0;g<m;g++)x.push(p(g*F));x.push(x[0]);const{spatialReference:f,doUnnormalization:T}=e,b=L([x.map(g=>e.localToMap(g)).filter(z)],f,T,!1),y=e.localToMap(p(Math.PI/2)),_=e.localToMap(p(0)),k=e.localToMap(p(-Math.PI/2)),H=e.localToMap(p(Math.PI));return{geometry:b,midpoints:y!=null&&_!=null&&k!=null&&H!=null?{top:w(y,f),right:w(_,f),bottom:w(k,f),left:w(H,f)}:null}}export{je as R,L as T,Be as U,He as W,Ae as b,Oe as j,Ee as k,Ge as v};
